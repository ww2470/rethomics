# NULL
# 
# #' Resample ROI data to a regular multivariate time series.
# #' 
# #' This function computes average (arithmetic mean) of all recorded variables at regular intervals by windowing the time series.
# #' Then, it performs linear interpolation in order to infer value of missing points. 
# #'
# #' @param d a datatable containing a time column (\code{d$t}) and one or several columns for recorded variables.
# #' Typicaly, this would be generated by  \code{link{loadROIsFromFile}}.
# #' @param fs the desired resampling frequency, in Hz.
# #' @return A new data.table with the same columns as \code{d}.
# #' @note The raw data is not guaranted to be a rugular time series in so far as 
# #' 1. the exact time stamp of every raw data point depends on the performance of the acquisition device,
# #' and 2. there could be missing data point when an animal is ocluded or not detected
# #'
# #' @examples
# #' \dontrun{
# #' FILE <- "result.db"
# #' # Load the three first ROIs
# #' ldfs <- loadROIsFromFile(FILE, rois=1:3)
# #' ###### Simple example resampling the first ROI at 0.1Hz (i.e. every 10s):
# #' d <- ldfs[roi_id == 2,]
# #' new_d <- interpolateROIData(d, fs=0.1)
# #' print(new_d)
# #' }
# #' @seealso \code{\link{loadROIsFromFile}} in order to load ROI data.
# #' @export
# interpolateROIData <- function(data, fs){
# 	d <- copy(data)
# 	ori_keys <- key(d)
# 	
# 	sampling_period <- 1/fs
# 	d[, t_round := sampling_period * round(d[,t] /sampling_period)]
# 	setkey(d, "t_round")
# 
# 	# FIXME! make another mean primitive prototype
# 	d <- d[,lapply(.SD,mean),by=t_round]
# 	
# 	# all possible required output times
# 	t_out <- seq(from=d[1,t_round], to=d[.N,t_round], by=sampling_period)
# 	
# 	t_to_interpolate <- setdiff(t_out, d$t_round)
# 	
# 	to_interpolate_dt <- d[t_round==t_to_interpolate]
# 	
# 	missing_points <- lapply(d, interpolate, t=d[,t], t_out=t_to_interpolate)
# 	
# 	
# 	missing_points <- as.data.table(missing_points)
# 	missing_points[ , t_round := t_to_interpolate]
#  	setkey(missing_points, "t_round")
#  	d <- rbind(missing_points, d)
#  	
# 	# we ensure the dt is time sorted
# 	d[,t:=t_round]
# 	setkey(d, "t")
# 	d$t_round <- NULL
# 	
# 	# we restitute old keys
# 	setkeyv(d, ori_keys)
# 	return(d)
# }
# 
# 
# interpolate <- function(t, yy, t_out){
# 	if(is.numeric(yy)){
# 		return(interp1(t, yy, t_out, "linear"))
# 	}
# 	
# 	else{
# 			yy <- as.factor(yy)
# 			levs <- levels(yy)
# 			yy <- unclass(yy)
# 			attr(yy, "levels") <- NULL
# 			out <- interp1(t, yy, t_out, "nearest")
# 			out <- as.factor(levs[out])
# 			return(out)
# 		}
# }
