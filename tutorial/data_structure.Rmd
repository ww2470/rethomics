---
title: "Data structure"
author: "Quentin Geissmann"
date: "27 August 2015"
output: html_document
---


Aims
-----

This tutorial is mainly intended for users who would like to contribute to `rethomics` development, make their own functions and understand how the package works at a lower level. 
It should be complementary to the [pdf documentation](../rethomics.pdf).
In this tutorial, we will learn how:

* Data tables can be used to to store arbitrary behavioural data.
* `rethomics` uses them to store data from multiple animals in the same table.
* To use the concept of data table "key".
* To use `rethomics` conventions.


Prerequisites
--------------

* Familiarity with R and statistical analysis
* Some familiarity with `data.table` package (at least have read the [tutorial](http://user2014.stat.ucla.edu/files/tutorial_Matt.pdf) and [getting started](https://github.com/Rdatatable/data.table/wiki/Getting-started))
* Having dowloaded the [data samples](sample_data.html) in `TUTO_DATA_DIR`

Data organisation
-----------------------

```{r, include=FALSE}
library(rethomics)
source("rprint.R")
```

We start by loading the tutorial data for later:
```{r}
DATA_EXAMPLE <- paste(TUTO_DATA_DIR,"ethoscope","RData", "ethoscope_tuto_data.RData",  sep="/")
# this will create a variable called `raw_data_exple_dt` that we will use later
load(DATA_EXAMPLE)
```


Raw behavioural data are time series of variables.
For each time point and each animal, their should be a set of variables.
Typically, variables are XY coordinates, orientation and other numbers, but they can also be categorical (or logical, e.g. whether the animal has crossed a light beam --TRUE of FALSE -- at a defined time point).

Let us make a simple **dummy** data table with random `x` and `y` positions to understand how that works:


```{r}
dt <- data.table(t=1:30,
           x=rnorm(30),
           y=rnorm(30),
           is_feeding = rnorm(30) >0
           )
print(dt)
```

In the resulting data table, `dt`, each of the 30 rows is a record of that animal at a time -- defined in column `t`.
The columns `x`, `y` and `is_feeding` are observed variables.
This is a very flexible format since:

* Time can be heterogeneous (*i.e.* the duration between consecutive observation is not constant).
* It is not a problem is we skip some rows (missing data).
* The same structure can be used for different acquisition platforms/tools, since we simply need to add/remove columns to match observed variables.


Keeping multiple animals in the same data structure
-----------------------------------------------------------------------

The data above represents a single animal.
However, in real life, we would like to work with multiple ones.
For instance, in the same experiments, you are likely to use multiple **regions** in which animals are located.

One approach could be to store each data table in some sort of list:

```{r}

# 10 reads
dt_region_1 <- data.table(t=1:10,
           x=rnorm(10),
           y=rnorm(10)
           )
# 15 reads
dt_region_2 <- data.table(t=1:15,
           x=rnorm(15),
           y=rnorm(15)
           )
#...
```

It is however *very impractical* to work with this type of *ad hock* structure.
If you are familiar with statistical modelling or data mining, you can probably see a better alternative.
The idea is to store both animals in the same table, and add a column to tell us from which animals (*i.e.* region) comes a read:

```{r}
# We make a column animal_id with the value 1
dt_region_1[, region_id := 1]

# We make a column animal_id with the value 2
dt_region_2[, region_id := 2]

# we simply put all the rows together an a new data tables called dt
dt <- rbind(dt_region_1, dt_region_2)
print(dt)
```

This is more flexibile and efficient.
Since all the data is together, it is very simple to filter it.
For instance, to get all the data (for all animals) where time is greater than 5:
```{r}
print(dt[t>5])
```

Or to get only the animal in region 1:
```{r}
print(dt[region_id==1])
```

For more advance uses, the data table framework a fantastic resource to summarise or aggregate the data.
We will just show a couple of examples to illustrate the power of data table in this context,
but you can follow [Matt Dowle's tutorial](http://user2014.stat.ucla.edu/files/tutorial_Matt.pdf) if you want to know more.

For instance, in order to get the number of read **for each animal**:

```{r}
dt[,
   .N,
   by="region_id"
   ]
```

So, the answer is N=10 in region 1 and N=15 in region 2.

Then, if we wanted to get the average x position **per animal**.

```{r}
dt[,
   mean(x),
   by="region_id"
   ]
```


Storing multiple experiments in one table
-------------------------------------------------------

Another real life issue is the fact that we may have *several experiments with the same regions id*.
For instance, if we performed one experiment every week for three week and, in each experiments, we had twenty animals (in regions one to twenty).
The issue is that now `region_id` is not sufficient to define a **unique animal** (indeed, three animals are in region 1, but from three different experiments).
In `rethomics`, the solution is to define a column named `experiment_id`.
In principle, for any unique combination of `region_id` **and** `experiment_id` we have a **unique animal**.

The `experiment_id` is generally a string of character including the date and time of the experiment and a unique identifier for the acquisition device.

The advantage of this approach is that we can still work (make graphs, stats, summaries) with individual animals, whislt keeping information about region of interest and experiments.


Using data table key
----------------------------

If you are already familiar with [relational databases](https://en.wikipedia.org/wiki/Relational_database), you will have understood that, together,  `region_id` and `experiment_id` are implicitly equivalent to a [foreign key](https://en.wikipedia.org/wiki/Foreign_key) which unique values refer to unique animals.


When you load data in `rethomics`, the resulting data table will use these column as keys, which makes it very efficient to process and store the data.
Let us use a small **real life** example:

```{r}
print(raw_data_exple_dt[1:200])
```

As you can see, there are many variables(columns), and most of them probably don't make much sense to you.
The important thing for us now is to see that the **three important variables** `t`, `region_id` and `experiment_id` are there. As I mentioned, a **key** is contained in this data:

```{r}
key(raw_data_exple_dt)
```

It means that for every unique combination of `date`, `machine_name`, `region_id`,`sex`,`experiment_id`, ..., there is only one animal (but many time points).
In the key, the columns `date`, `machine_name`, `sex` are optional columns defining variables for each animal (*e.g.* a given animal can be male or female).
These optional variables are *redundant* in so far as they could be deduced from `region_id` and `experiment_id`.
It is however very convenient to keep them in the key.
If, say, we want to compute the average x position **for each animal**, but we would like to keep information regarding the sex of this animal, so we can tell, for instance, if males sleep more than females:



```{r}
summary_dt <- raw_data_exple_dt[,# all rows
                        .(x_avg = mean(x)), # number of alseep is TRUE over total (.N)
                        # this is the IMPORTANT bit.
                        # we do this for each animal independently
                        by = key(raw_data_exple_dt)
              ]
print(summary_dt)
```

As a result, we have computed one number for each unique animals, and kept the additional variables such as sex.
This integrates very well with `R` and makes is straightforward to do perform statistics and draw graphs:

```{r, plot=TRUE}
# a graph using ggplot
ggplot(summary_dt, aes(sex,x_avg, fill=sex)) + geom_boxplot()
```


Conventions
---------------

Time is **always** named `t` and expressed in **seconds**.
Time is always compared to a reference point. 
The reference time can be either the start of the experiment,
or a time-point during the first day of the experiment (see tutorial on [loading the data](ethoscope_data.html))

Distance units such as `x`, `y`, `w` and `h` variables are espressed as a **fraction of the region width**, *not* in pixels or cm.
`x` and `y` are coordinates from the **top-left** of the region in which the animal was recorded.




